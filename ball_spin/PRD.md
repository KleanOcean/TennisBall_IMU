# Tennis Ball Spin Visualizer - 产品需求文档 (PRD)

---

## 1. 项目概述

| 字段 | 内容 |
|------|------|
| **项目名称** | Tennis Ball Spin Visualizer（网球旋转可视化器） |
| **目标** | 在 M5Stack ATOM S3 的 128x128 像素 IPS 屏幕上，实时 3D 渲染一颗网球，根据板载 IMU 陀螺仪数据驱动旋转，直观展示网球的自旋状态 |
| **核心价值** | 让教练和球员在训练现场即时看到击球旋转的方向、速度和类型，无需外部设备或后处理 |
| **应用场景** | 网球训练中分析击球旋转——上旋（topspin）、侧旋（sidespin）、陀螺旋转（gyro spin）。将传感器安装于球拍或模拟球体上，实时捕捉并可视化旋转信息 |
| **开发框架** | PlatformIO + Arduino Framework |
| **核心依赖** | M5Unified (v0.1.16+)，内含 M5GFX 图形库和 IMU 驱动 |

---

## 2. 硬件规格

### 2.1 主控板：M5Stack ATOM S3

| 参数 | 规格 |
|------|------|
| MCU | ESP32-S3，双核 Xtensa LX7，主频 240MHz |
| Flash | 8MB |
| RAM | 512KB SRAM + 2MB PSRAM |
| 屏幕 | 128x128 GC9107 IPS 全彩显示屏 |
| IMU | MPU6886（6轴：3轴加速度计 + 3轴陀螺仪） |
| 按钮 | BtnA（正面物理按钮） |
| 接口 | USB Type-C（供电 + 烧录 + 串口监控，波特率 115200） |
| 烧录速度 | 1,500,000 bps |

### 2.2 IMU 传感器：MPU6886

| 参数 | 说明 |
|------|------|
| 陀螺仪量程 | 可配置，默认 ±2000 °/s |
| 输出数据 | 三轴角速度（°/s），通过 `M5.Imu.getImuData()` 获取 |
| 当前使用 | 仅使用陀螺仪数据（`d.gyro.x/y/z`），加速度计数据未使用 |

---

## 3. 核心功能

### 3.1 3D 网球渲染

在 128x128 屏幕上渲染一颗具有 3D 质感的网球，球心位于屏幕坐标 `(64, 54)`（略偏上方，为底部文字信息留出空间），球体半径为 34 像素。

#### 渲染层次（从底到顶）

1. **黑色背景**：`fillSprite(0x0000)` 清屏
2. **投射阴影**：在球心右下方偏移 `(+3, +3)` 处绘制同半径深色圆 `(0x1082)`，模拟光照下的地面投影
3. **球体本体**：填充圆，使用网球标志性的荧光黄色 `(0xCE40)`
4. **高光效果**：在球心左上方偏移 `(-8, -8)` 处绘制较小圆（半径为球体的 2/3），使用亮黄色 `(0xDF00)`，模拟 Phong 光照模型的镜面高光
5. **网球缝线**：3D 旋转后投影绘制（详见 3.1.1）
6. **轮廓线**：使用灰色 `(0x6B4D)` 绘制球体边缘圆环，增强立体感
7. **旋转轴**：红色轴线穿过球心（详见 3.4）
8. **文字叠加层**：RPM、角速度数值、旋转类型标签

#### 3.1.1 网球缝线（Seam）

网球缝线是球体表面最具辨识度的特征曲线。本项目采用参数方程在单位球面上生成缝线点，再通过四元数旋转和正交投影显示到屏幕上。

**球面参数方程：**

```
t ∈ [0, 2π)
lat(t) = A · sin(2t)        // 纬度随经度摆动，A ≈ 0.44 rad ≈ 25.2°
x(t) = cos(lat) · cos(t)    // 单位球面 x 坐标
y(t) = cos(lat) · sin(t)    // 单位球面 y 坐标
z(t) = sin(lat)             // 单位球面 z 坐标
```

**实现细节：**

- 采样点数：72 个，均匀分布在 `t ∈ [0, 2π)` 上
- 在 `setup()` 中预计算（pre-compute）所有采样点到 `seamPts[]` 数组，运行时零分配
- 每帧对每个点执行四元数旋转 `qrot(orient, seamPts[i])`，得到世界坐标系下的位置
- 正交投影到屏幕：`sx = CX + p.x × BALL_R`，`sy = CY - p.y × BALL_R`
- **可见性判断**：
  - `z > 0.05`：前面可见部分，使用白色 `(0xFFFF)` 绘制
  - `-0.15 < z ≤ 0.05`：球体边缘附近，使用暗灰色 `(0x4208)` 绘制，增添深度感
  - `z ≤ -0.15`：背面，不绘制
- 相邻采样点之间用 `drawLine` 连接，形成连续曲线

### 3.2 四元数姿态追踪

使用四元数（Quaternion）表示球体在三维空间中的朝向，避免万向锁（gimbal lock），实现平滑的任意轴旋转。

#### 数据流

```
IMU 陀螺仪 → 角速度 (°/s) → 转换 rad/s → 构造增量四元数 Δq → 累积旋转 → 归一化
```

#### 四元数积分算法

每帧执行以下步骤：

1. **读取角速度**：从 IMU 获取 `gyro.x/y/z`（单位 °/s）
2. **转换单位**：乘以 `π/180` 转换为 rad/s
3. **计算时间步长**：`dt = (nowUs - lastUs) × 10⁻⁶`，使用微秒计时器确保精度，异常值钳制为 33ms
4. **计算旋转角度和轴**：
   - 角速度大小：`ωmag = √(gx² + gy² + gz²)`
   - 旋转角度：`θ = ωmag × dt`
   - 旋转轴：`(gx, gy, gz) / ωmag`（单位向量）
5. **构造增量四元数**（轴角表示法）：
   ```
   Δq = { cos(θ/2), axis.x·sin(θ/2), axis.y·sin(θ/2), axis.z·sin(θ/2) }
   ```
6. **累积旋转**：`orient = orient × Δq`（四元数右乘，表示在体坐标系中施加旋转）
7. **归一化**：每帧调用 `qnorm()` 防止浮点累积误差导致四元数长度偏离 1.0
8. **静止过滤**：当 `ωmag < 0.01 rad/s` 时跳过积分，避免噪声积累

### 3.3 旋转速率显示 (RPM)

#### 计算公式

```
RPM_raw = |ω| / 6.0
```

其中 `|ω| = √(gx² + gy² + gz²)`，单位 °/s。除以 6 是因为：`1 RPM = 360°/60s = 6°/s`。

#### 滤波

采用一阶指数移动平均（EMA）低通滤波器，平滑系数 `α = 0.08`：

```
filtRPM += 0.08 × (rawRPM - filtRPM)
```

该重度滤波确保屏幕上的数字不会因传感器噪声而快速跳动，提供稳定的读数体验。

#### 显示规则

- **静止时**（`filtRPM < 1.0`）：显示 `"READY"`，表示设备就绪待用
- **旋转时**（`filtRPM ≥ 1.0`）：显示整数 RPM 值，例如 `"1250 RPM"`
- **字体**：FreeSansBold 9pt，大字号，位于屏幕顶部居中
- **颜色**：白色 `(0xFFFF)`

### 3.4 旋转轴可视化

在球体上叠加一条红色轴线，直观指示当前旋转轴方向。

#### 实现逻辑

1. 取滤波后的三轴角速度 `(filtGx, filtGy, filtGz)` 构造单位向量（体坐标系下的旋转轴方向）
2. 使用当前姿态四元数 `orient` 将体坐标系旋转轴变换到世界坐标系
3. 沿轴线正负方向各延伸 `BALL_R + 12` 像素，绘制红色线段
4. 在正方向端点绘制半径为 3 像素的红色圆点，标识旋转方向

#### 显示规则

- 仅当 `filtRPM ≥ 3.0` 且角速度大小 `≥ 1.0 °/s` 时显示
- 低于阈值时隐藏轴线，避免静止状态下陀螺仪噪声产生的虚假方向指示

### 3.5 旋转类型识别

根据三轴角速度的绝对值判断主导旋转轴，自动识别旋转类型。

#### 识别逻辑

```
ax = |filtGx|, ay = |filtGy|, az = |filtGz|

if ax > ay && ax > az → TOPSPIN     // X轴主导：上旋/下旋
if ay > ax && ay > az → SIDESPIN    // Y轴主导：侧旋
otherwise             → GYRO        // Z轴主导：陀螺旋转（子弹旋转）
```

#### 显示规则

- 仅当 `filtRPM > 5.0` 时显示旋转类型标签
- 显示位置：屏幕右下角
- 颜色：白色

#### 旋转类型说明

| 类型 | 主导轴 | 网球运动含义 |
|------|--------|------------|
| TOPSPIN | X轴 | 上旋或下旋。球绕水平横轴旋转，正手上旋击球和反手下旋切削的典型旋转方式 |
| SIDESPIN | Y轴 | 侧旋。球绕竖直轴旋转，发球中的侧旋发球（slice serve）常见此类旋转 |
| GYRO | Z轴 | 陀螺旋转。球绕飞行方向轴旋转（类似子弹），某些发球技术会产生此类旋转 |

### 3.6 三轴角速度显示

在屏幕底部区域显示实时的三轴角速度数值，帮助用户了解每个轴上的旋转分量。

#### 实现细节

- **滤波**：EMA 低通滤波，`α = 0.15`（比 RPM 的 0.08 更灵敏，响应更快）
  ```
  filtGx += 0.15 × (gyro.x - filtGx)
  ```
- **显示格式**：`"120  -45  890 dps"`（取整显示，单位 °/s）
- **轴标签**：底部独立一行，带颜色编码
  - X：红色 `(0xF800)`
  - Y：绿色 `(0x07E0)`
  - Z：蓝色 `(0x001F)`
- **字体**：Font0（小字号系统字体）
- **文字颜色**：灰色 `(0x8410)`

### 3.7 按钮功能

| 按钮 | 操作 | 功能 |
|------|------|------|
| BtnA | 按下 | 重置四元数为单位四元数 `{1, 0, 0, 0}`，球体回到初始朝向。用于校准或重新开始观察 |

---

## 4. 技术实现

### 4.1 四元数运算库

项目内嵌实现了三个核心四元数函数，无外部数学库依赖：

#### `qmul(Quat a, Quat b) → Quat`

标准 Hamilton 四元数乘法：

```
w = a.w·b.w - a.x·b.x - a.y·b.y - a.z·b.z
x = a.w·b.x + a.x·b.w + a.y·b.z - a.z·b.y
y = a.w·b.y - a.x·b.z + a.y·b.w + a.z·b.x
z = a.w·b.z + a.x·b.y - a.y·b.x + a.z·b.w
```

#### `qnorm(Quat &q)`

原地归一化，将四元数长度恢复为 1.0：

```
len = √(w² + x² + y² + z²)
if len > 0.0001 then q /= len
```

#### `qrot(Quat q, Vec3 v) → Vec3`

优化的四元数-向量旋转，等价于 `q × v × q⁻¹` 但运算量减少约 50%。利用向量叉积展开避免完整的两次四元数乘法：

```
t = 2 × (q.xyz × v)           // 叉积的 2 倍
result = v + q.w × t + (q.xyz × t)  // 最终旋转结果
```

仅需 18 次乘法 + 12 次加法，而完整的 `q × v × q⁻¹` 需约 32 次乘法。

### 4.2 渲染管线

每帧按固定顺序执行以下渲染步骤（画家算法，后绘制的覆盖先绘制的）：

```
1. fillSprite(黑色)                    → 清除帧缓冲
2. fillCircle(CX+3, CY+3, R, 阴影色)   → 投射阴影
3. fillCircle(CX, CY, R, 球体色)       → 球体本体
4. fillCircle(CX-8, CY-8, R×2/3, 高光色) → 高光
5. drawSeam()                          → 72 段缝线（四元数旋转→投影→可见性裁剪→绘制）
6. drawCircle(CX, CY, R, 轮廓色)       → 球体轮廓线
7. drawSpinAxis()                      → 旋转轴（红色线 + 端点圆点）
8. drawString(RPM / READY)             → RPM 文字
9. drawString(三轴角速度)               → 底部数值
10. drawString(X Y Z 标签)             → 轴标签
11. drawString(旋转类型)               → TOPSPIN / SIDESPIN / GYRO
12. pushSprite(0, 0)                   → 将帧缓冲推送到屏幕
```

### 4.3 双缓冲渲染

使用 `M5Canvas` 精灵（Sprite）作为离屏帧缓冲区：

- `createSprite(128, 128)`：创建 128x128 的内存画布
- 所有绘制操作写入内存画布，而非直接写屏
- `pushSprite(0, 0)`：一次性将完整帧推送到物理屏幕
- **效果**：彻底消除画面闪烁（flickering），保证每帧显示的都是完整渲染结果

### 4.4 帧率与性能

| 指标 | 数值 |
|------|------|
| 目标帧率 | ~60 FPS（每帧延迟 16ms） |
| 四元数旋转计算 | 72 个缝线点 × qrot 运算 ≈ 微秒级 |
| 瓶颈 | SPI 屏幕传输（128×128×16bit ≈ 32KB/帧） |
| 实际帧率 | 受限于 SPI 带宽和 `delay(16)`，预估 30-60 FPS |

### 4.5 IMU 错误处理

在 `setup()` 中检测 IMU 是否正常初始化：

- 若 `M5.Imu.isEnabled()` 返回 `false`，屏幕显示红色背景 + `"IMU FAIL!"` 错误信息
- 进入无限循环 `while(1)`，阻止程序继续执行
- 确保用户在硬件故障时获得明确反馈

### 4.6 时间步长保护

```cpp
if (dt > 0.1f) dt = 0.033f;
```

当计时器溢出或首帧出现异常大 `dt` 值时，钳制为 33ms（约 30 FPS），防止四元数积分因过大时间步长产生错误旋转。

---

## 5. 色彩方案

| 元素 | RGB565 值 | 近似 RGB | 说明 |
|------|-----------|----------|------|
| 背景 | `0x0000` | `(0, 0, 0)` | 纯黑，最大化球体对比度 |
| 球体 | `0xCE40` | `(206, 200, 0)` | 网球标志性的荧光黄绿色（optic yellow） |
| 高光 | `0xDF00` | `(222, 224, 0)` | 比球体本色更亮的黄色，模拟光源反射 |
| 阴影 | `0x1082` | `(16, 16, 16)` | 深灰近黑，模拟球体投射阴影 |
| 轮廓 | `0x6B4D` | `(107, 105, 107)` | 中灰色，增强球体边缘轮廓 |
| 缝线（前面） | `0xFFFF` | `(255, 255, 255)` | 白色，网球缝线的真实颜色 |
| 缝线（边缘） | `0x4208` | `(66, 65, 66)` | 暗灰色，表示远离观察者的缝线段 |
| 旋转轴 | `0xF800` | `(255, 0, 0)` | 红色，醒目标识旋转轴方向 |
| 文字 | `0xFFFF` | `(255, 255, 255)` | 白色，主要信息文字 |
| 灰色文字 | `0x8410` | `(132, 130, 132)` | 灰色，辅助信息（角速度数值） |
| X 轴标签 | `0xF800` | `(255, 0, 0)` | 红色 |
| Y 轴标签 | `0x07E0` | `(0, 255, 0)` | 绿色 |
| Z 轴标签 | `0x001F` | `(0, 0, 255)` | 蓝色 |

---

## 6. UI 布局

```
┌────────────────────────────────┐
│         1250 RPM               │  ← RPM 或 "READY"（FreeSansBold 9pt，顶部居中）
│                                │
│           ╭──~──╮              │
│          ╱ ~     ╲             │
│    ←────│    ●    │────→       │  ← 旋转轴（红色线 + 方向端点）
│          ╲   ~ ~ ╱            │
│           ╰──~──╯             │  ← 网球（荧光黄 + 白色缝线）
│                                │
│    120  -45  890 dps           │  ← 三轴角速度数值（灰色，居中）
│    X    Y    Z     TOPSPIN     │  ← 轴标签（彩色） + 旋转类型（白色，右下）
└────────────────────────────────┘

球心坐标: (64, 54)   球体半径: 34px
屏幕尺寸: 128 × 128 px
```

**布局说明：**

- 球心故意偏上（Y=54 而非 Y=64），为底部两行文字信息留出空间
- RPM 显示在最顶部，是用户最关注的核心数据
- 旋转轴线从球心向两侧延伸超出球体边缘 12 像素，确保在球体表面可见
- 底部分两行：角速度数值行 + 轴标签/旋转类型行

---

## 7. 数据结构

### 7.1 核心类型

```cpp
struct Vec3 { float x, y, z; };          // 三维向量
struct Quat { float w, x, y, z; };       // 四元数（w 为标量部分）
```

### 7.2 全局状态

| 变量 | 类型 | 说明 |
|------|------|------|
| `orient` | `Quat` | 当前球体姿态四元数，初始为 `{1,0,0,0}`（单位四元数） |
| `seamPts[72]` | `Vec3[]` | 预计算的缝线采样点（单位球面坐标） |
| `filtGx/Gy/Gz` | `float` | 低通滤波后的三轴角速度（°/s），用于显示和旋转类型判断 |
| `filtRPM` | `float` | 低通滤波后的旋转速率（RPM） |
| `lastUs` | `uint32_t` | 上一帧的微秒时间戳，用于计算 dt |
| `canvas` | `M5Canvas` | 128x128 离屏帧缓冲区 |

---

## 8. 滤波参数

| 滤波器 | 平滑系数 α | 响应特性 | 用途 |
|--------|-----------|---------|------|
| 角速度显示 | 0.15 | 较快响应，约 6-7 帧达到 63% | 底部角速度数值、旋转轴方向、旋转类型判断 |
| RPM 显示 | 0.08 | 重度滤波，约 12-13 帧达到 63% | 顶部 RPM 数值显示，避免数字跳动 |

**时间常数估算**（假设 60 FPS）：
- 角速度滤波：~100ms 响应时间
- RPM 滤波：~200ms 响应时间

---

## 9. 约束与限制

### 9.1 当前限制

1. **仅使用陀螺仪**：未融合加速度计数据，长时间运行会产生姿态漂移（drift）
2. **无自动校零**：陀螺仪零偏（bias）未补偿，可能导致静止时缓慢漂移
3. **单条缝线**：真实网球有两条对称缝线，当前仅渲染一条
4. **正交投影**：使用正交投影而非透视投影，缺乏近大远小的透视效果（对于 34px 半径的小球影响可忽略）
5. **旋转类型判断简单**：仅基于主导轴的绝对值比较，未考虑复合旋转的情况

### 9.2 性能约束

- ESP32-S3 单精度浮点运算，`sinf/cosf` 调用在缝线绘制中已通过预计算优化
- 128x128 SPI 屏幕带宽是帧率的主要瓶颈
- `delay(16)` 硬编码帧间隔，未使用自适应帧率控制

---

## 10. 未来规划

### 10.1 传感器融合（高优先级）

引入加速度计数据，实现 Madgwick 或 Mahony 互补滤波器，将重力向量作为绝对参考修正陀螺仪漂移。预期效果：
- 消除长时间使用的姿态漂移
- 自动校准初始朝向（对齐重力方向）
- 更准确的旋转轴估计

### 10.2 数据记录与回放（中优先级）

- 将旋转数据（时间戳 + 四元数 + 角速度 + RPM）记录到 ESP32 Flash 或外接 SD 卡
- 赛后回放分析：逐帧重现每一次击球的旋转变化
- 统计每次击球的峰值 RPM、平均旋转速率、主要旋转类型

### 10.3 BLE 无线传输（中优先级）

- 通过 BLE (Bluetooth Low Energy) 实时传输旋转数据到手机 App
- 手机端可实现更大屏幕的 3D 可视化、历史数据图表、训练报告
- 支持多设备同时连接（教练同时监控多位球员）

### 10.4 智能击球识别（低优先级）

- 基于旋转特征（RPM 曲线、旋转轴变化模式、加速度峰值）自动识别击球类型：
  - 正手上旋（forehand topspin）
  - 反手切削（backhand slice）
  - 平击发球（flat serve）
  - 侧旋发球（slice serve）
  - 踢式发球（kick serve）
- 可能需要机器学习模型或基于规则的分类器

### 10.5 渲染增强（低优先级）

- 添加第二条缝线，完整还原网球外观
- 球体表面毛毡纹理（dithering 模拟）
- 旋转轨迹拖尾效果
- 自适应帧率控制（取消硬编码 delay）
