<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>YoTB Dashboard</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0a0e27;
  --surface:#111633;
  --accent:#C8D820;
  --text-primary:#FFFFFF;
  --text-secondary:#667788;
  --border:#1a2040;
  --glow:rgba(200,216,32,0.3);
  --ring:#222244;
}
body{background:var(--bg);color:var(--text-primary);font-family:system-ui,-apple-system,'Segoe UI',sans-serif;min-height:100vh;overflow-x:hidden}

/* ====== Header ====== */
.header{display:flex;align-items:center;padding:14px 24px;background:var(--surface);border-bottom:1px solid var(--border);gap:24px;position:sticky;top:0;z-index:50}
.logo{font-size:1.5rem;font-weight:800;color:#fff;letter-spacing:2px;flex-shrink:0;user-select:none}
.logo span{color:var(--accent)}
.nav-tabs{display:flex;gap:0;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;flex:1}
.nav-tabs::-webkit-scrollbar{display:none}
.nav-tab{padding:10px 20px;font-size:0.82rem;font-weight:700;color:var(--text-secondary);cursor:pointer;border:none;background:none;letter-spacing:1.5px;white-space:nowrap;position:relative;transition:color 0.2s}
.nav-tab:hover{color:#aabbcc}
.nav-tab.active{background:#fff;color:#0a0e27;border-radius:20px}
.session-indicator{display:flex;align-items:center;gap:8px;font-size:0.82rem;color:var(--text-secondary);flex-shrink:0;margin-left:auto}
.status-dot{width:9px;height:9px;border-radius:50%;display:inline-block;transition:background 0.3s}
.status-dot.active{background:#44FF44;box-shadow:0 0 6px #44FF44;animation:pulse 1.5s infinite}
.status-dot.ended{background:#556677}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}

/* ====== Tab Content ====== */
.tab-content{display:none;padding:20px;max-width:1440px;margin:0 auto}
.tab-content.active{display:block}

/* ====== Cards ====== */
.card{background:var(--surface);border:1px solid var(--border);border-radius:14px;padding:18px;position:relative}
.card-title{font-size:0.8rem;color:var(--text-secondary);text-transform:uppercase;letter-spacing:1.5px;margin-bottom:14px;font-weight:600}

/* ====== DASHBOARD TAB ====== */
.dashboard-grid{display:grid;grid-template-columns:25% 1fr 35%;gap:18px;align-items:start}
@media(max-width:1100px){.dashboard-grid{grid-template-columns:1fr 1fr;}.dashboard-grid .col-center{order:-1;grid-column:1/-1}}
@media(max-width:768px){.dashboard-grid{grid-template-columns:1fr;}.dashboard-grid .col-center{order:-1}}

/* -- RPM Gauge Column -- */
.gauge-wrap{display:flex;flex-direction:column;align-items:center;padding:10px 0 0}
#gaugeCanvas{max-width:100%;height:auto}
.mini-stats{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:16px;width:100%}
.mini-stat{background:var(--bg);border-radius:10px;padding:14px 10px;text-align:center;border:1px solid var(--border)}
.mini-stat .val{font-size:1.6rem;font-weight:800;color:var(--accent);font-family:'Courier New',monospace;line-height:1.1}
.mini-stat .lbl{font-size:0.7rem;color:var(--text-secondary);margin-top:5px}

/* -- 3D Ball Column -- */
.col-center{display:flex;flex-direction:column;align-items:center}
.ball-glow-wrap{position:relative;display:flex;align-items:center;justify-content:center}
.ball-glow{position:absolute;width:75%;height:75%;border-radius:50%;background:radial-gradient(circle,rgba(200,216,32,0.38) 0%,rgba(200,216,32,0.12) 40%,transparent 70%);filter:blur(35px);pointer-events:none;opacity:0.9}
#ballCanvas{position:relative;z-index:1;max-width:100%;height:auto}
.ball-label{margin-top:10px;font-size:0.75rem;color:var(--text-secondary);text-align:center;letter-spacing:1px}

/* -- Polar Plot Column -- */
.polar-container{display:flex;flex-direction:column;align-items:center}
.polar-container svg{max-width:100%;height:auto}
.legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:12px;justify-content:center}
.legend-btn{display:flex;align-items:center;gap:5px;padding:4px 10px;border-radius:16px;border:1px solid var(--border);background:var(--bg);cursor:pointer;font-size:0.72rem;color:var(--text-primary);transition:opacity 0.2s}
.legend-btn:hover{border-color:rgba(200,216,32,0.4)}
.legend-btn.hidden{opacity:0.25}
.legend-dot{width:9px;height:9px;border-radius:50%;display:inline-block}

/* -- Spin Distribution Bar -- */
.dist-bar-wrap{margin-top:14px}
.dist-row{display:flex;align-items:center;gap:8px;margin-bottom:7px;font-size:0.78rem}
.dist-label{width:55px;text-align:right;color:var(--text-secondary);flex-shrink:0;font-size:0.72rem}
.dist-bar-bg{flex:1;height:16px;background:var(--bg);border-radius:4px;overflow:hidden;position:relative}
.dist-bar-fill{height:100%;border-radius:4px;transition:width 0.4s ease}
.dist-pct{width:36px;text-align:left;color:var(--text-secondary);font-family:'Courier New',monospace;font-size:0.72rem}

/* -- Timeline -- */
.timeline-section{margin-top:18px}
.timeline-scroll{overflow-x:auto;padding:8px 0;scrollbar-width:thin;scrollbar-color:var(--border) transparent}
.timeline-scroll::-webkit-scrollbar{height:6px}
.timeline-scroll::-webkit-scrollbar-track{background:transparent}
.timeline-scroll::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
.timeline-bar{position:relative;height:80px;min-width:100%;background:var(--bg);border-radius:8px;border:1px solid var(--border)}
.shot-mark{position:absolute;bottom:0;width:40px;transform:translateX(-20px);cursor:pointer;text-align:center;transition:opacity 0.2s}
.shot-mark:hover{opacity:0.8}
.shot-mark.selected .shot-dot{border-color:var(--accent);box-shadow:0 0 8px var(--glow)}
.shot-dot{width:12px;height:12px;border-radius:50%;margin:0 auto 2px;border:2px solid rgba(255,255,255,0.15);transition:all 0.2s}
.shot-rpm{font-size:0.68rem;color:var(--text-primary);font-family:'Courier New',monospace}
.shot-type-label{font-size:0.58rem;font-weight:600;margin-top:1px}

/* ====== SHOTS TAB ====== */
.session-table{width:100%;border-collapse:collapse;font-size:0.82rem}
.session-table th{text-align:left;padding:10px 14px;color:var(--accent);border-bottom:1px solid var(--border);font-weight:700;font-size:0.72rem;letter-spacing:1px;text-transform:uppercase}
.session-table td{padding:10px 14px;border-bottom:1px solid rgba(255,255,255,0.03);cursor:pointer;transition:background 0.15s}
.session-table tr.clickable:hover td{background:rgba(200,216,32,0.04)}
.session-table tr.active-row td{background:rgba(200,216,32,0.08)}
.status-badge{display:inline-block;padding:3px 10px;border-radius:10px;font-size:0.7rem;font-weight:700;letter-spacing:0.5px}
.status-badge.recording{background:rgba(68,255,68,0.12);color:#44FF44}
.status-badge.ended{background:rgba(102,119,136,0.15);color:var(--text-secondary)}
.delete-btn{background:none;border:1px solid #c0392b;color:#c0392b;border-radius:6px;padding:3px 12px;font-size:0.72rem;cursor:pointer;transition:all 0.2s}
.delete-btn:hover{background:#c0392b;color:#fff}
.actions-bar{display:flex;gap:10px;margin-top:16px;flex-wrap:wrap}
.btn{padding:9px 22px;border:none;border-radius:8px;font-size:0.82rem;cursor:pointer;font-weight:700;transition:opacity 0.2s,background 0.2s,transform 0.1s;letter-spacing:0.5px}
.btn:active{transform:scale(0.97)}
.btn-accent{background:var(--accent);color:var(--bg)}
.btn-accent:hover{background:#d8e830}
.btn-outline{background:none;border:1px solid var(--border);color:var(--text-primary)}
.btn-outline:hover{border-color:var(--accent);color:var(--accent)}

/* -- Shot detail table (Shots tab) -- */
.shot-detail-table{width:100%;border-collapse:collapse;font-size:0.78rem;margin-top:18px}
.shot-detail-table th{text-align:left;padding:8px 12px;color:var(--accent);border-bottom:1px solid var(--border);font-weight:700;font-size:0.7rem;letter-spacing:1px;text-transform:uppercase}
.shot-detail-table td{padding:8px 12px;border-bottom:1px solid rgba(255,255,255,0.03);font-family:'Courier New',monospace;color:var(--text-secondary)}

/* ====== ANALYSIS TAB ====== */
.analysis-grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
@media(max-width:768px){.analysis-grid{grid-template-columns:1fr}}
.analysis-polar-wrap{display:flex;flex-direction:column;align-items:center}
.analysis-polar-wrap svg{max-width:100%;height:auto}
.stats-summary{display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin-bottom:18px}
.stats-summary .mini-stat{background:var(--surface);border:1px solid var(--border)}

/* ====== SETTINGS TAB ====== */
.settings-grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
@media(max-width:768px){.settings-grid{grid-template-columns:1fr}}
.setting-group{margin-bottom:16px}
.setting-label{font-size:0.72rem;color:var(--text-secondary);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px;font-weight:600}
.setting-value{font-size:0.88rem;color:var(--text-primary);font-family:'Courier New',monospace;padding:10px 14px;background:var(--bg);border-radius:8px;border:1px solid var(--border);word-break:break-all}
.setting-placeholder{font-size:0.82rem;color:var(--text-secondary);font-style:italic;padding:10px 14px;background:var(--bg);border-radius:8px;border:1px dashed var(--border)}

/* ====== Spin type text colors ====== */
.sc-TOPSPIN{color:#FF6B6B}.sc-BACKSPIN{color:#4ECDC4}
.sc-SIDE_L,.sc-SIDE_R,.sc-SIDESPIN{color:#FFE66D}
.sc-SLICE{color:#A8E6CF}.sc-FLAT{color:#888}.sc-MIXED{color:#DDA0DD}

/* ====== Tooltip ====== */
.tooltip{position:absolute;background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:10px 14px;font-size:0.78rem;pointer-events:none;z-index:100;white-space:nowrap;box-shadow:0 8px 24px rgba(0,0,0,0.5);display:none}
.tooltip .tt-rpm{font-size:1.15rem;font-weight:800;color:var(--accent);font-family:'Courier New',monospace}
.tooltip .tt-type{font-weight:700;margin-top:3px}
.tooltip .tt-time{color:var(--text-secondary);font-size:0.7rem;margin-top:3px}

/* ====== No data ====== */
.no-data{text-align:center;color:var(--text-secondary);padding:40px 0;font-size:0.85rem}

/* ====== Responsive ====== */
@media(max-width:768px){
  .header{padding:10px 14px;gap:12px;flex-wrap:wrap}
  .logo{font-size:1.2rem}
  .nav-tab{padding:8px 14px;font-size:0.75rem}
  .session-indicator{font-size:0.75rem}
  .tab-content{padding:12px}
  .card{padding:14px}
  #ballCanvas{width:90vw !important;height:auto !important}
  .settings-grid,.analysis-grid{grid-template-columns:1fr}
}
</style>
</head>
<body>

<!-- ====== HEADER ====== -->
<div class="header">
    <div class="logo">Yo<span>TB</span></div>
    <nav class="nav-tabs" id="navTabs">
        <button class="nav-tab active" data-tab="dashboard">DASHBOARD</button>
        <button class="nav-tab" data-tab="shots">SHOTS</button>
        <button class="nav-tab" data-tab="analysis">ANALYSIS</button>
        <button class="nav-tab" data-tab="settings">SETTINGS</button>
    </nav>
    <div class="session-indicator">
        <span class="status-dot ended" id="sessionDot"></span>
        <span id="sessionText">Select Session</span>
    </div>
</div>

<!-- ====== DASHBOARD TAB ====== -->
<div class="tab-content active" id="tab-dashboard">
    <div class="dashboard-grid">
        <!-- LEFT: RPM Gauge + Stats -->
        <div class="col-left">
            <div class="card">
                <div class="gauge-wrap">
                    <canvas id="gaugeCanvas" width="280" height="200"></canvas>
                </div>
                <div class="mini-stats">
                    <div class="mini-stat"><div class="val" id="statTotal">0</div><div class="lbl">击球数</div></div>
                    <div class="mini-stat"><div class="val" id="statAvgRPM">0</div><div class="lbl">平均 RPM</div></div>
                    <div class="mini-stat"><div class="val" id="statMaxRPM">0</div><div class="lbl">最高 RPM</div></div>
                    <div class="mini-stat"><div class="val" id="statMaxG">0</div><div class="lbl">最大 G</div></div>
                </div>
            </div>
        </div>

        <!-- CENTER: 3D Wireframe Tennis Ball -->
        <div class="col-center">
            <div class="card">
                <div class="ball-glow-wrap">
                    <div class="ball-glow"></div>
                    <div style="position:relative">
                        <canvas id="ballCanvas" width="380" height="380"></canvas>
                        <button id="ballToggle" onclick="toggleBallMode()" style="position:absolute;top:8px;right:8px;z-index:10;background:#111633cc;border-radius:6px;padding:4px 10px;font-size:0.75rem;color:#667788;cursor:pointer;border:1px solid #1a2040;transition:color 0.2s,border-color 0.2s" onmouseenter="this.style.color='#C8D820';this.style.borderColor='#C8D820'" onmouseleave="this.style.color='#667788';this.style.borderColor='#1a2040'">WIRE</button>
                    </div>
                </div>
                <div class="ball-label">3D SPIN VISUALIZATION</div>
            </div>
        </div>

        <!-- RIGHT: Polar Plot + Distribution -->
        <div class="col-right">
            <div class="card">
                <div class="card-title">Spin Axis Plot</div>
                <div class="polar-container">
                    <svg id="polarSvg" viewBox="0 0 400 400" width="400" height="400"></svg>
                    <div class="legend" id="legend"></div>
                </div>
                <div class="dist-bar-wrap" id="distChart"></div>
            </div>
        </div>
    </div>

    <!-- Timeline -->
    <div class="card timeline-section">
        <div class="card-title">Shot Timeline</div>
        <div class="timeline-scroll">
            <div class="timeline-bar" id="timelineBar"></div>
        </div>
    </div>
</div>

<!-- ====== SHOTS TAB ====== -->
<div class="tab-content" id="tab-shots">
    <div class="card">
        <div class="card-title">Session History</div>
        <div id="sessionTableWrap"></div>
        <div class="actions-bar">
            <button class="btn btn-accent" onclick="exportCSV()">Export CSV</button>
            <button class="btn btn-outline" onclick="exportJSON()">Export JSON</button>
        </div>
    </div>
    <div class="card" style="margin-top:18px">
        <div class="card-title">Shot Details</div>
        <div id="shotDetailWrap"><div class="no-data">Select a session to view shot details</div></div>
    </div>
</div>

<!-- ====== ANALYSIS TAB ====== -->
<div class="tab-content" id="tab-analysis">
    <div class="stats-summary" id="analysisSummary"></div>
    <div class="analysis-grid">
        <div class="card">
            <div class="card-title">Spin Axis Distribution</div>
            <div class="analysis-polar-wrap">
                <svg id="analysisPolarSvg" viewBox="0 0 500 500" width="500" height="500"></svg>
                <div class="legend" id="analysisLegend"></div>
            </div>
        </div>
        <div class="card">
            <div class="card-title">Spin Type Breakdown</div>
            <div class="dist-bar-wrap" id="analysisDistChart"></div>
            <div style="margin-top:20px">
                <div class="card-title">Shot-by-Shot Data</div>
                <div style="max-height:400px;overflow-y:auto" id="analysisShotTable"></div>
            </div>
        </div>
    </div>
</div>

<!-- ====== SETTINGS TAB ====== -->
<div class="tab-content" id="tab-settings">
    <div class="settings-grid">
        <div class="card">
            <div class="card-title">Connection</div>
            <div class="setting-group">
                <div class="setting-label">Dashboard URL</div>
                <div class="setting-value" id="settingURL">-</div>
            </div>
            <div class="setting-group">
                <div class="setting-label">API Base</div>
                <div class="setting-value" id="settingAPI">/api/sessions</div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Active Session</div>
                <div class="setting-value" id="settingSession">None</div>
            </div>
        </div>
        <div class="card">
            <div class="card-title">Preferences</div>
            <div class="setting-group">
                <div class="setting-label">Session Notes</div>
                <div class="setting-placeholder">Session notes editing coming soon...</div>
            </div>
            <div class="setting-group">
                <div class="setting-label">Theme</div>
                <div class="setting-placeholder">Theme toggle coming soon...</div>
            </div>
        </div>
    </div>
</div>

<!-- Tooltip element -->
<div class="tooltip" id="tooltip">
    <div class="tt-rpm"></div>
    <div class="tt-type"></div>
    <div class="tt-time"></div>
</div>

<script>
'use strict';

// ============================================================
// Constants & State
// ============================================================

const SPIN_COLORS = {
    TOPSPIN:  '#FF6B6B',
    BACKSPIN: '#4ECDC4',
    SIDE_L:   '#FFE66D',
    SIDE_R:   '#FFE66D',
    SIDESPIN: '#FFE66D',
    SLICE:    '#A8E6CF',
    FLAT:     '#888888',
    MIXED:    '#DDA0DD'
};

const SPIN_LABELS = {
    TOPSPIN:  '上旋',
    BACKSPIN: '下旋',
    SIDE_L:   '左侧旋',
    SIDE_R:   '右侧旋',
    SIDESPIN: '侧旋',
    SLICE:    '切削',
    FLAT:     '平击',
    MIXED:    '混合'
};

const CX = 200, CY = 200, MAX_R = 170;
const RPM_RINGS = [50, 100, 150, 200];

// Analysis polar plot constants (larger)
const ACX = 250, ACY = 250, AMAX_R = 210;

let allSessions = [];
let currentSessionId = null;
let currentSession = null;
let currentShots = [];
let pollTimer = null;
let hiddenTypes = new Set();
let selectedShotIdx = -1;

// Ball rotation state
let ballRotY = 0;
let ballRotX = 0.3;
let ballAnimFrame = null;
let ballMode = (typeof sessionStorage !== 'undefined' && sessionStorage.getItem('ballMode')) || 'wire';

// ============================================================
// Icosphere generation (once at startup)
// ============================================================

const ICO_PHI = (1 + Math.sqrt(5)) / 2;
const icoBaseV = [[-1,ICO_PHI,0],[1,ICO_PHI,0],[-1,-ICO_PHI,0],[1,-ICO_PHI,0],
  [0,-1,ICO_PHI],[0,1,ICO_PHI],[0,-1,-ICO_PHI],[0,1,-ICO_PHI],
  [ICO_PHI,0,-1],[ICO_PHI,0,1],[-ICO_PHI,0,-1],[-ICO_PHI,0,1]];
const icoVerts = icoBaseV.map(v => {
  const l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  return { x: v[0]/l, y: v[1]/l, z: v[2]/l };
});

const icoFaces = [[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
  [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
  [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
  [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]];

// Subdivide once
const midCache = {};
function getIcoMid(i, j) {
  const key = Math.min(i,j) + ':' + Math.max(i,j);
  if (midCache[key] !== undefined) return midCache[key];
  const a = icoVerts[i], b = icoVerts[j];
  const mx = (a.x+b.x)/2, my = (a.y+b.y)/2, mz = (a.z+b.z)/2;
  const l = Math.sqrt(mx*mx + my*my + mz*mz);
  icoVerts.push({ x: mx/l, y: my/l, z: mz/l });
  midCache[key] = icoVerts.length - 1;
  return midCache[key];
}

const icoEdges = [];
const edgeSet = new Set();
// Subdivide TWICE for denser mesh (~480 edges)
let icoFacesCur = icoFaces;
for (let sub = 0; sub < 2; sub++) {
  const nf = [];
  for (const [a,b,c] of icoFacesCur) {
    const ab = getIcoMid(a,b), bc = getIcoMid(b,c), ca = getIcoMid(c,a);
    nf.push([a,ab,ca],[b,bc,ab],[c,ca,bc],[ab,bc,ca]);
  }
  icoFacesCur = nf;
}
for (const [a,b,c] of icoFacesCur) {
  [[a,b],[b,c],[c,a]].forEach(([i,j]) => {
    const key = Math.min(i,j) + ':' + Math.max(i,j);
    if (!edgeSet.has(key)) { edgeSet.add(key); icoEdges.push([i,j]); }
  });
}

// ============================================================
// Tab Switching
// ============================================================

function initTabs() {
    const tabs = document.querySelectorAll('.nav-tab');
    const savedTab = sessionStorage.getItem('yotb-active-tab');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const target = tab.dataset.tab;
            switchTab(target);
        });
    });

    if (savedTab && document.getElementById('tab-' + savedTab)) {
        switchTab(savedTab);
    }
}

function switchTab(name) {
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

    const tab = document.querySelector('.nav-tab[data-tab="' + name + '"]');
    const content = document.getElementById('tab-' + name);
    if (tab) tab.classList.add('active');
    if (content) content.classList.add('active');

    sessionStorage.setItem('yotb-active-tab', name);

    // Re-render tab-specific content
    if (name === 'analysis') {
        renderAnalysisTab();
    } else if (name === 'shots') {
        renderSessionTable();
        renderShotDetail();
    } else if (name === 'settings') {
        updateSettings();
    }
}

// ============================================================
// SVG Namespace helper
// ============================================================

const SVG_NS = 'http://www.w3.org/2000/svg';
function svgEl(tag, attrs) {
    const el = document.createElementNS(SVG_NS, tag);
    for (const [k, v] of Object.entries(attrs || {})) el.setAttribute(k, v);
    return el;
}

// ============================================================
// RPM Gauge (Canvas)
// ============================================================

function drawGauge(avgRPM, maxRPM) {
    const canvas = document.getElementById('gaugeCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const cx = w / 2;
    const cy = h * 0.78;
    const radius = Math.min(w, h) * 0.42;
    const startAngle = 0.75 * Math.PI;
    const endAngle = 2.25 * Math.PI;
    const totalSweep = endAngle - startAngle;

    // Track arc
    ctx.beginPath();
    ctx.arc(cx, cy, radius, startAngle, endAngle, false);
    ctx.strokeStyle = '#222244';
    ctx.lineWidth = 14;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Fill arc (proportion of avgRPM relative to gaugeMax)
    const gaugeMax = Math.max(maxRPM, 200, avgRPM * 1.5);
    const fillRatio = Math.min(avgRPM / gaugeMax, 1);
    if (fillRatio > 0) {
        ctx.beginPath();
        ctx.arc(cx, cy, radius, startAngle, startAngle + totalSweep * fillRatio, false);
        ctx.strokeStyle = '#C8D820';
        ctx.lineWidth = 14;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Glow effect
        ctx.shadowColor = 'rgba(200,216,32,0.5)';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, startAngle, startAngle + totalSweep * fillRatio, false);
        ctx.strokeStyle = 'rgba(200,216,32,0.3)';
        ctx.lineWidth = 14;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
    }

    // Center RPM text
    ctx.fillStyle = '#C8D820';
    ctx.font = 'bold ' + Math.round(radius * 0.65) + 'px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(Math.round(avgRPM), cx, cy - 10);

    // Labels
    ctx.fillStyle = '#667788';
    ctx.font = '600 ' + Math.round(radius * 0.2) + 'px system-ui, sans-serif';
    ctx.fillText('RPM', cx, cy + radius * 0.3);
    ctx.font = Math.round(radius * 0.16) + 'px system-ui, sans-serif';
    ctx.fillText('AVG', cx, cy + radius * 0.5);
}

// ============================================================
// 3D Wireframe Tennis Ball (Canvas)
// ============================================================

function initBall() {
    if (ballAnimFrame) cancelAnimationFrame(ballAnimFrame);
    animateBall();
}

function animateBall() {
    drawBall();
    ballAnimFrame = requestAnimationFrame(animateBall);
}

function drawBall() {
    if (ballMode === 'solid') { drawBallSolid(); return; }
    const canvas = document.getElementById('ballCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const cx = w / 2, cy = h / 2;
    const R = Math.min(w, h) * 0.38;

    // Rotation matrices
    const cosY = Math.cos(ballRotY), sinY = Math.sin(ballRotY);
    const cosX = Math.cos(ballRotX), sinX = Math.sin(ballRotX);

    function rotate(x, y, z) {
        // Rotate around Y axis
        let x1 = x * cosY + z * sinY;
        let z1 = -x * sinY + z * cosY;
        // Rotate around X axis
        let y1 = y * cosX - z1 * sinX;
        let z2 = y * sinX + z1 * cosX;
        return { x: x1, y: y1, z: z2 };
    }

    function project(p) {
        return { sx: cx + p.x, sy: cy - p.y, depth: p.z / R };
    }

    // Multi-layer glow
    const glowGrad = ctx.createRadialGradient(cx, cy, R * 0.2, cx, cy, R * 1.5);
    glowGrad.addColorStop(0, 'rgba(200,216,32,0.15)');
    glowGrad.addColorStop(0.4, 'rgba(200,216,32,0.08)');
    glowGrad.addColorStop(0.7, 'rgba(200,216,32,0.03)');
    glowGrad.addColorStop(1, 'rgba(200,216,32,0)');
    ctx.fillStyle = glowGrad;
    ctx.fillRect(0, 0, w, h);

    // Draw geodesic mesh edges
    for (const [i, j] of icoEdges) {
      const va = icoVerts[i], vb = icoVerts[j];
      // Apply rotation
      const ra = rotate(va.x * R, va.y * R, va.z * R);
      const rb = rotate(vb.x * R, vb.y * R, vb.z * R);
      const pa = project(ra), pb = project(rb);
      const avgDepth = (pa.depth + pb.depth) / 2;
      const alpha = 0.10 + 0.90 * Math.max(0, avgDepth);
      ctx.beginPath();
      ctx.moveTo(pa.sx, pa.sy);
      ctx.lineTo(pb.sx, pb.sy);
      ctx.strokeStyle = 'rgba(200,216,32,' + alpha.toFixed(2) + ')';
      ctx.lineWidth = 0.8;
      ctx.stroke();
    }

    // Tennis ball seam curve
    const seamPoints = [];
    for (let i = 0; i <= 72; i++) {
        const t = (i / 72) * 2 * Math.PI;
        const lat = 0.44 * Math.sin(2 * t);
        const lon = t;
        // Convert to Cartesian
        const x = R * Math.cos(lat) * Math.cos(lon);
        const y = R * Math.cos(lat) * Math.sin(lon);
        const z = R * Math.sin(lat);
        const rotated = rotate(x, y, z);
        const proj = project(rotated);
        seamPoints.push(proj);
    }
    drawLineStrip(ctx, seamPoints, 4, true);
}

function drawLineStrip(ctx, points, lineWidth, isSeam) {
    if (points.length < 2) return;
    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i], p2 = points[i + 1];
        const avgDepth = (p1.depth + p2.depth) / 2;
        const alpha = 0.12 + 0.88 * Math.max(0, avgDepth);

        ctx.beginPath();
        ctx.moveTo(p1.sx, p1.sy);
        ctx.lineTo(p2.sx, p2.sy);

        if (isSeam) {
            ctx.strokeStyle = 'rgba(200,216,32,' + (alpha * 1.0).toFixed(3) + ')';
            ctx.lineWidth = lineWidth;
            // Glow on front-facing seam
            if (avgDepth > 0.2) {
                ctx.shadowColor = 'rgba(200,216,32,0.5)';
                ctx.shadowBlur = 6;
            } else {
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        } else {
            ctx.strokeStyle = 'rgba(200,216,32,' + (alpha * 0.45).toFixed(3) + ')';
            ctx.lineWidth = lineWidth;
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }
        ctx.stroke();
    }
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
}

// ============================================================
// Ball Mode Toggle
// ============================================================

function toggleBallMode() {
    ballMode = (ballMode === 'wire') ? 'solid' : 'wire';
    sessionStorage.setItem('ballMode', ballMode);
    document.getElementById('ballToggle').textContent = ballMode === 'wire' ? 'WIRE' : 'SOLID';
}

// ============================================================
// Solid Tennis Ball Rendering
// ============================================================

function drawBallSolid() {
    const canvas = document.getElementById('ballCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0, 0, w, h);

    const cx = w / 2, cy = h / 2;
    const R = Math.min(w, h) * 0.38;

    // Rotation matrices (same as drawBall)
    const cosY = Math.cos(ballRotY), sinY = Math.sin(ballRotY);
    const cosX = Math.cos(ballRotX), sinX = Math.sin(ballRotX);

    function rotate(x, y, z) {
        let x1 = x * cosY + z * sinY;
        let z1 = -x * sinY + z * cosY;
        let y1 = y * cosX - z1 * sinX;
        let z2 = y * sinX + z1 * cosX;
        return { x: x1, y: y1, z: z2 };
    }

    function project(p) {
        return { sx: cx + p.x, sy: cy - p.y, depth: p.z / R };
    }

    // Draw filled sphere with radial gradient
    const grad = ctx.createRadialGradient(cx - R * 0.25, cy - R * 0.25, R * 0.05, cx, cy, R);
    grad.addColorStop(0, '#E8F040');
    grad.addColorStop(1, '#C8D820');
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();

    // Thin dark outline around the sphere
    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(40,50,10,0.4)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Tennis ball seam curve (same parametric formula as drawBall)
    const seamPoints = [];
    for (let i = 0; i <= 72; i++) {
        const t = (i / 72) * 2 * Math.PI;
        const lat = 0.44 * Math.sin(2 * t);
        const lon = t;
        const x = R * Math.cos(lat) * Math.cos(lon);
        const y = R * Math.cos(lat) * Math.sin(lon);
        const z = R * Math.sin(lat);
        const rotated = rotate(x, y, z);
        const proj = project(rotated);
        seamPoints.push(proj);
    }

    // Draw seam segments with depth-based visibility
    for (let i = 0; i < seamPoints.length - 1; i++) {
        const p1 = seamPoints[i], p2 = seamPoints[i + 1];
        const avgDepth = (p1.depth + p2.depth) / 2;

        if (avgDepth > 0) {
            // Front-facing: full opacity white
            ctx.beginPath();
            ctx.moveTo(p1.sx, p1.sy);
            ctx.lineTo(p2.sx, p2.sy);
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2.5;
            ctx.stroke();
        } else if (avgDepth > -0.15) {
            // Back-facing but near edge: faint gray
            ctx.beginPath();
            ctx.moveTo(p1.sx, p1.sy);
            ctx.lineTo(p2.sx, p2.sy);
            ctx.strokeStyle = 'rgba(180,180,180,0.35)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }
        // Deeper back: don't draw
    }
}

// ============================================================
// Initialize Polar Plot (Dashboard version)
// ============================================================

function initPolarPlot() {
    buildPolarSvg('polarSvg', CX, CY, MAX_R, RPM_RINGS);
}

function buildPolarSvg(svgId, cx, cy, maxR, rings) {
    const svg = document.getElementById(svgId);
    if (!svg) return;
    svg.innerHTML = '';

    // Background
    svg.appendChild(svgEl('rect', {
        x: 0, y: 0,
        width: parseInt(svg.getAttribute('viewBox').split(' ')[2]),
        height: parseInt(svg.getAttribute('viewBox').split(' ')[3]),
        fill: '#0a0e27', rx: 12
    }));

    // Concentric RPM rings
    const maxRPMRing = rings[rings.length - 1];
    rings.forEach(rpm => {
        const r = (rpm / maxRPMRing) * maxR;
        svg.appendChild(svgEl('circle', {
            cx: cx, cy: cy, r: r,
            fill: 'none', stroke: '#222244', 'stroke-width': 1,
            'stroke-dasharray': '4,4'
        }));
        // RPM label
        const label = svgEl('text', {
            x: cx + 4, y: cy - r - 3,
            fill: '#667788', 'font-size': '10', 'font-family': 'Courier New, monospace'
        });
        label.textContent = rpm;
        svg.appendChild(label);
    });

    // Cross-hair lines
    svg.appendChild(svgEl('line', {x1: cx - maxR - 10, y1: cy, x2: cx + maxR + 10, y2: cy, stroke: '#222244', 'stroke-width': 0.8}));
    svg.appendChild(svgEl('line', {x1: cx, y1: cy - maxR - 10, x2: cx, y2: cy + maxR + 10, stroke: '#222244', 'stroke-width': 0.8}));

    // Axis labels
    const labels = [
        {text: '右侧旋', x: cx + maxR + 14, y: cy + 4, anchor: 'start'},
        {text: '上旋',   x: cx, y: cy - maxR - 14, anchor: 'middle'},
        {text: '左侧旋', x: cx - maxR - 14, y: cy + 4, anchor: 'end'},
        {text: '下旋',   x: cx, y: cy + maxR + 22, anchor: 'middle'}
    ];
    labels.forEach(l => {
        const t = svgEl('text', {
            x: l.x, y: l.y,
            fill: '#667788', 'font-size': '11', 'font-weight': '600',
            'text-anchor': l.anchor, 'font-family': 'system-ui, sans-serif'
        });
        t.textContent = l.text;
        svg.appendChild(t);
    });

    // Group for shot points
    svg.appendChild(svgEl('g', {id: svgId + '-shots'}));
}

// ============================================================
// Render shots on polar plot
// ============================================================

function renderPolarShots() {
    renderPolarShotsOn('polarSvg', CX, CY, MAX_R, 'polarSvg-shots');
}

function renderPolarShotsOn(svgId, cx, cy, maxR, groupId) {
    const svg = document.getElementById(svgId);
    if (!svg) return;
    let group = document.getElementById(groupId);
    if (!group) {
        group = svgEl('g', {id: groupId});
        svg.appendChild(group);
    }
    group.innerHTML = '';

    if (!currentShots.length) return;

    // Determine max RPM from data for scaling
    let dataMaxRPM = 0;
    currentShots.forEach(s => { if (s.rpm > dataMaxRPM) dataMaxRPM = s.rpm; });
    const scaleRPM = Math.max(dataMaxRPM, RPM_RINGS[RPM_RINGS.length - 1]);

    const lastIdx = currentShots.length - 1;

    currentShots.forEach((shot, idx) => {
        const type = shot.spin_type || 'MIXED';
        if (hiddenTypes.has(type)) return;

        const phi = shot.spin_axis_phi;
        if (phi == null) return;

        const angleRad = phi * Math.PI / 180;
        const rPx = (shot.rpm / scaleRPM) * maxR;

        const px = cx + rPx * Math.cos(angleRad);
        const py = cy - rPx * Math.sin(angleRad);

        const color = SPIN_COLORS[type] || '#888';
        const isLatest = (idx === lastIdx);
        const isSelected = (idx === selectedShotIdx);
        const radius = isLatest ? 8 : 6;

        const circle = svgEl('circle', {
            cx: px.toFixed(1),
            cy: py.toFixed(1),
            r: radius,
            fill: color,
            opacity: 0.85,
            stroke: (isLatest || isSelected) ? '#fff' : 'none',
            'stroke-width': (isLatest || isSelected) ? 2 : 0,
            cursor: 'pointer',
            'data-idx': idx
        });

        circle.addEventListener('mouseenter', (e) => showTooltip(e, shot));
        circle.addEventListener('mouseleave', hideTooltip);
        circle.addEventListener('click', () => selectShot(idx));

        group.appendChild(circle);
    });
}

// ============================================================
// Tooltip
// ============================================================

function showTooltip(e, shot) {
    const tip = document.getElementById('tooltip');
    const type = shot.spin_type || 'MIXED';
    tip.querySelector('.tt-rpm').textContent = Math.round(shot.rpm) + ' RPM';
    tip.querySelector('.tt-type').textContent = (SPIN_LABELS[type] || type);
    tip.querySelector('.tt-type').style.color = SPIN_COLORS[type] || '#e0e0e0';
    tip.querySelector('.tt-time').textContent = shot.local_ts || '';
    tip.style.display = 'block';

    let tx = e.pageX + 12;
    let ty = e.pageY - 10;
    if (tx + 160 > window.innerWidth) tx = e.pageX - 170;
    if (ty < 0) ty = 10;
    tip.style.left = tx + 'px';
    tip.style.top = ty + 'px';
}

function hideTooltip() {
    document.getElementById('tooltip').style.display = 'none';
}

// ============================================================
// Legend / filter buttons
// ============================================================

function renderLegend() {
    renderLegendInto('legend');
}

function renderLegendInto(elId) {
    const el = document.getElementById(elId);
    if (!el) return;
    el.innerHTML = '';
    const types = ['TOPSPIN', 'BACKSPIN', 'SIDE_L', 'SIDE_R', 'SLICE', 'FLAT', 'MIXED'];
    types.forEach(t => {
        const btn = document.createElement('div');
        btn.className = 'legend-btn' + (hiddenTypes.has(t) ? ' hidden' : '');
        btn.innerHTML = '<span class="legend-dot" style="background:' + SPIN_COLORS[t] + '"></span>' + (SPIN_LABELS[t] || t);
        btn.addEventListener('click', () => {
            if (hiddenTypes.has(t)) hiddenTypes.delete(t);
            else hiddenTypes.add(t);
            renderLegend();
            renderLegendInto('analysisLegend');
            renderPolarShots();
            renderAnalysisPolar();
        });
        el.appendChild(btn);
    });
}

// ============================================================
// Stats
// ============================================================

function computeStats() {
    let sumRPM = 0, mxRPM = 0, mxG = 0;
    currentShots.forEach(s => {
        sumRPM += (s.rpm || 0);
        if (s.rpm > mxRPM) mxRPM = s.rpm;
        if (s.peak_g > mxG) mxG = s.peak_g;
    });
    return {
        total: currentShots.length,
        avgRPM: currentShots.length ? Math.round(sumRPM / currentShots.length) : 0,
        maxRPM: Math.round(mxRPM),
        maxG: mxG
    };
}

function updateStats() {
    const stats = computeStats();

    document.getElementById('statTotal').textContent = stats.total;
    document.getElementById('statAvgRPM').textContent = stats.avgRPM;
    document.getElementById('statMaxRPM').textContent = stats.maxRPM;
    document.getElementById('statMaxG').textContent = stats.maxG.toFixed(1);

    // Update RPM gauge
    drawGauge(stats.avgRPM, stats.maxRPM);
}

// ============================================================
// Spin Distribution Chart
// ============================================================

function updateDistribution() {
    renderDistInto('distChart');
}

function renderDistInto(elId) {
    const wrap = document.getElementById(elId);
    if (!wrap) return;
    wrap.innerHTML = '';

    if (!currentShots.length) {
        wrap.innerHTML = '<div class="no-data">暂无数据</div>';
        return;
    }

    const counts = {};
    currentShots.forEach(s => {
        const t = s.spin_type || 'MIXED';
        counts[t] = (counts[t] || 0) + 1;
    });

    const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
    const total = currentShots.length;

    sorted.forEach(([type, count]) => {
        const pct = (count / total * 100);
        const row = document.createElement('div');
        row.className = 'dist-row';
        row.innerHTML =
            '<div class="dist-label">' + (SPIN_LABELS[type] || type) + '</div>' +
            '<div class="dist-bar-bg"><div class="dist-bar-fill" style="width:' + pct.toFixed(1) + '%;background:' + (SPIN_COLORS[type] || '#888') + '"></div></div>' +
            '<div class="dist-pct">' + pct.toFixed(0) + '%</div>';
        wrap.appendChild(row);
    });
}

// ============================================================
// Shot Timeline
// ============================================================

function renderTimeline() {
    const bar = document.getElementById('timelineBar');
    if (!bar) return;
    bar.innerHTML = '';

    if (!currentShots.length) {
        bar.style.width = '100%';
        bar.innerHTML = '<div class="no-data" style="line-height:80px">暂无击球数据</div>';
        return;
    }

    const barW = Math.max(currentShots.length * 50, bar.parentElement.clientWidth);
    bar.style.width = barW + 'px';

    const firstTs = currentShots[0].device_ts || 0;
    const lastTs = currentShots[currentShots.length - 1].device_ts || 0;
    const timeSpan = Math.max(lastTs - firstTs, 1);

    currentShots.forEach((s, i) => {
        const pct = currentShots.length === 1 ? 0.5 : (s.device_ts - firstTs) / timeSpan;
        const x = 20 + pct * (barW - 40);
        const type = s.spin_type || 'MIXED';
        const color = SPIN_COLORS[type] || '#888';

        // Scale dot by RPM
        let dataMaxRPM = 0;
        currentShots.forEach(sh => { if (sh.rpm > dataMaxRPM) dataMaxRPM = sh.rpm; });
        const dotScale = dataMaxRPM > 0 ? 0.6 + 0.4 * (s.rpm / dataMaxRPM) : 1;
        const dotSize = Math.round(8 + dotScale * 8);

        const mk = document.createElement('div');
        mk.className = 'shot-mark' + (i === selectedShotIdx ? ' selected' : '');
        mk.style.left = x + 'px';
        mk.addEventListener('click', () => selectShot(i));

        mk.innerHTML =
            '<div class="shot-dot" style="background:' + color + ';width:' + dotSize + 'px;height:' + dotSize + 'px"></div>' +
            '<div class="shot-rpm">' + Math.round(s.rpm) + '</div>' +
            '<div class="shot-type-label sc-' + type + '">' + (SPIN_LABELS[type] || type) + '</div>';

        bar.appendChild(mk);
    });
}

function selectShot(idx) {
    selectedShotIdx = idx;
    renderPolarShots();
    renderTimeline();
}

// ============================================================
// Session History Table (Shots tab)
// ============================================================

function renderSessionTable() {
    const wrap = document.getElementById('sessionTableWrap');
    if (!wrap) return;

    if (!allSessions.length) {
        wrap.innerHTML = '<div class="no-data">暂无会话记录</div>';
        return;
    }

    let html = '<table class="session-table"><thead><tr>' +
        '<th>#</th><th>开始时间</th><th>状态</th><th>时长</th><th>击球</th><th>平均RPM</th><th>最高RPM</th><th>操作</th>' +
        '</tr></thead><tbody>';

    allSessions.forEach(s => {
        const isActive = (currentSessionId === s.id);
        const isRecording = !s.end_time;
        const startStr = s.start_time ? s.start_time.replace('T', ' ').substring(0, 19) : '-';
        const durStr = s.duration_sec ? formatDuration(s.duration_sec) : (isRecording ? '录制中' : '-');
        const statusBadge = isRecording
            ? '<span class="status-badge recording">录制中</span>'
            : '<span class="status-badge ended">已结束</span>';

        html += '<tr class="clickable' + (isActive ? ' active-row' : '') + '" data-sid="' + s.id + '">' +
            '<td>' + s.id + '</td>' +
            '<td>' + startStr + '</td>' +
            '<td>' + statusBadge + '</td>' +
            '<td>' + durStr + '</td>' +
            '<td>' + (s.total_shots || 0) + '</td>' +
            '<td>' + Math.round(s.avg_rpm || 0) + '</td>' +
            '<td>' + Math.round(s.max_rpm || 0) + '</td>' +
            '<td><button class="delete-btn" data-sid="' + s.id + '">删除</button></td>' +
            '</tr>';
    });

    html += '</tbody></table>';
    wrap.innerHTML = html;

    // Attach click handlers to rows
    wrap.querySelectorAll('tr.clickable').forEach(row => {
        row.addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-btn')) return;
            const sid = parseInt(row.dataset.sid);
            loadSession(sid);
        });
    });

    // Attach delete handlers
    wrap.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const sid = parseInt(btn.dataset.sid);
            deleteSession(sid);
        });
    });
}

// Shot detail table for Shots tab
function renderShotDetail() {
    const wrap = document.getElementById('shotDetailWrap');
    if (!wrap) return;

    if (!currentShots.length) {
        wrap.innerHTML = '<div class="no-data">Select a session to view shot details</div>';
        return;
    }

    let html = '<table class="shot-detail-table"><thead><tr>' +
        '<th>#</th><th>Time</th><th>Type</th><th>RPM</th><th>Axis Phi</th><th>Axis Theta</th><th>Peak G</th>' +
        '</tr></thead><tbody>';

    currentShots.forEach((s, i) => {
        const type = s.spin_type || 'MIXED';
        html += '<tr>' +
            '<td>' + (i + 1) + '</td>' +
            '<td>' + (s.local_ts || '-') + '</td>' +
            '<td><span class="sc-' + type + '">' + (SPIN_LABELS[type] || type) + '</span></td>' +
            '<td style="color:#C8D820">' + Math.round(s.rpm || 0) + '</td>' +
            '<td>' + (s.spin_axis_phi != null ? s.spin_axis_phi.toFixed(1) + '\u00B0' : '-') + '</td>' +
            '<td>' + (s.spin_axis_theta != null ? s.spin_axis_theta.toFixed(1) + '\u00B0' : '-') + '</td>' +
            '<td>' + (s.peak_g != null ? s.peak_g.toFixed(1) : '-') + '</td>' +
            '</tr>';
    });

    html += '</tbody></table>';
    wrap.innerHTML = html;
}

function formatDuration(sec) {
    if (sec < 60) return Math.round(sec) + '秒';
    const m = Math.floor(sec / 60);
    const s = Math.round(sec % 60);
    if (m < 60) return m + '分' + (s > 0 ? s + '秒' : '');
    const h = Math.floor(m / 60);
    const rm = m % 60;
    return h + '时' + (rm > 0 ? rm + '分' : '');
}

// ============================================================
// Analysis Tab
// ============================================================

function renderAnalysisTab() {
    // Summary stats
    const summaryWrap = document.getElementById('analysisSummary');
    if (summaryWrap) {
        const stats = computeStats();
        summaryWrap.innerHTML =
            '<div class="mini-stat"><div class="val">' + stats.total + '</div><div class="lbl">击球数</div></div>' +
            '<div class="mini-stat"><div class="val">' + stats.avgRPM + '</div><div class="lbl">平均 RPM</div></div>' +
            '<div class="mini-stat"><div class="val">' + stats.maxRPM + '</div><div class="lbl">最高 RPM</div></div>' +
            '<div class="mini-stat"><div class="val">' + stats.maxG.toFixed(1) + '</div><div class="lbl">最大 G</div></div>';
    }

    // Polar plot (larger)
    initAnalysisPolar();
    renderAnalysisPolar();
    renderLegendInto('analysisLegend');

    // Distribution
    renderDistInto('analysisDistChart');

    // Shot-by-shot table
    renderAnalysisShotTable();
}

function initAnalysisPolar() {
    buildPolarSvg('analysisPolarSvg', ACX, ACY, AMAX_R, RPM_RINGS);
}

function renderAnalysisPolar() {
    renderPolarShotsOn('analysisPolarSvg', ACX, ACY, AMAX_R, 'analysisPolarSvg-shots');
}

function renderAnalysisShotTable() {
    const wrap = document.getElementById('analysisShotTable');
    if (!wrap) return;

    if (!currentShots.length) {
        wrap.innerHTML = '<div class="no-data">暂无数据</div>';
        return;
    }

    let html = '<table class="shot-detail-table"><thead><tr>' +
        '<th>#</th><th>Time</th><th>Type</th><th>RPM</th><th>Phi</th><th>Theta</th><th>Peak G</th><th>Duration</th>' +
        '</tr></thead><tbody>';

    currentShots.forEach((s, i) => {
        const type = s.spin_type || 'MIXED';
        html += '<tr>' +
            '<td>' + (i + 1) + '</td>' +
            '<td>' + (s.local_ts || '-') + '</td>' +
            '<td><span class="sc-' + type + '">' + (SPIN_LABELS[type] || type) + '</span></td>' +
            '<td style="color:#C8D820">' + Math.round(s.rpm || 0) + '</td>' +
            '<td>' + (s.spin_axis_phi != null ? s.spin_axis_phi.toFixed(1) + '\u00B0' : '-') + '</td>' +
            '<td>' + (s.spin_axis_theta != null ? s.spin_axis_theta.toFixed(1) + '\u00B0' : '-') + '</td>' +
            '<td>' + (s.peak_g != null ? s.peak_g.toFixed(1) : '-') + '</td>' +
            '<td>' + (s.duration_ms != null ? (s.duration_ms / 1000).toFixed(2) + 's' : '-') + '</td>' +
            '</tr>';
    });

    html += '</tbody></table>';
    wrap.innerHTML = html;
}

// ============================================================
// Settings Tab
// ============================================================

function updateSettings() {
    const urlEl = document.getElementById('settingURL');
    const sessionEl = document.getElementById('settingSession');
    if (urlEl) urlEl.textContent = window.location.href;
    if (sessionEl) {
        sessionEl.textContent = currentSessionId
            ? 'Session #' + currentSessionId + (currentSession && !currentSession.end_time ? ' (Recording)' : ' (Ended)')
            : 'None';
    }
}

// ============================================================
// API calls
// ============================================================

async function fetchSessions() {
    try {
        const resp = await fetch('/api/sessions');
        allSessions = await resp.json();
    } catch (e) {
        console.error('Failed to fetch sessions:', e);
        allSessions = [];
    }
}

async function loadSession(sid) {
    currentSessionId = sid;
    selectedShotIdx = -1;

    // Stop any existing poll
    if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }

    try {
        const [sessionResp, shotsResp] = await Promise.all([
            fetch('/api/sessions/' + sid),
            fetch('/api/sessions/' + sid + '/shots')
        ]);

        currentSession = await sessionResp.json();
        currentShots = await shotsResp.json();
    } catch (e) {
        console.error('Failed to load session:', e);
        return;
    }

    // Update session header
    updateSessionHeader();

    // Render everything
    renderPolarShots();
    updateStats();
    updateDistribution();
    renderTimeline();
    renderSessionTable();
    renderShotDetail();

    // If session is still active (no end_time), poll for updates
    if (currentSession && !currentSession.end_time) {
        pollTimer = setInterval(() => pollShots(sid), 2000);
    }
}

async function pollShots(sid) {
    if (currentSessionId !== sid) {
        clearInterval(pollTimer);
        pollTimer = null;
        return;
    }

    try {
        const [sessionResp, shotsResp] = await Promise.all([
            fetch('/api/sessions/' + sid),
            fetch('/api/sessions/' + sid + '/shots')
        ]);
        currentSession = await sessionResp.json();
        const newShots = await shotsResp.json();

        if (newShots.length !== currentShots.length) {
            currentShots = newShots;
            renderPolarShots();
            updateStats();
            updateDistribution();
            renderTimeline();
            renderShotDetail();
        }

        updateSessionHeader();

        if (currentSession.end_time) {
            clearInterval(pollTimer);
            pollTimer = null;
            await fetchSessions();
            renderSessionTable();
        }
    } catch (e) {
        console.error('Poll error:', e);
    }
}

function updateSessionHeader() {
    const dot = document.getElementById('sessionDot');
    const txt = document.getElementById('sessionText');

    if (!currentSession) {
        dot.className = 'status-dot ended';
        txt.textContent = 'Select Session';
        return;
    }

    const isRecording = !currentSession.end_time;
    dot.className = 'status-dot ' + (isRecording ? 'active' : 'ended');

    const samples = currentSession.total_samples || 0;
    txt.textContent = 'Session #' + currentSession.id + (isRecording ? ' Recording' : ' Ended') + ' \u00B7 ' + samples + ' samples';
}

async function deleteSession(sid) {
    if (!confirm('确定要删除会话 #' + sid + ' 及其所有数据吗？')) return;

    try {
        await fetch('/api/sessions/' + sid, { method: 'DELETE' });
    } catch (e) {
        console.error('Delete failed:', e);
        return;
    }

    if (currentSessionId === sid) {
        currentSessionId = null;
        currentSession = null;
        currentShots = [];
        selectedShotIdx = -1;
        if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
        updateSessionHeader();
        renderPolarShots();
        updateStats();
        updateDistribution();
        renderTimeline();
        renderShotDetail();
    }

    await fetchSessions();
    renderSessionTable();
}

// ============================================================
// Export functions
// ============================================================

function exportCSV() {
    if (!currentSessionId) { alert('请先选择一个会话'); return; }
    window.open('/api/sessions/' + currentSessionId + '/export', '_blank');
}

function exportJSON() {
    if (!currentSessionId) { alert('请先选择一个会话'); return; }

    const data = {
        session: currentSession,
        shots: currentShots
    };

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'session_' + currentSessionId + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
}

// ============================================================
// Initialization
// ============================================================

async function init() {
    initTabs();
    initPolarPlot();
    renderLegend();
    initBall();

    // Initialize ball toggle button text based on persisted mode
    const ballToggleBtn = document.getElementById('ballToggle');
    if (ballToggleBtn) {
        ballToggleBtn.textContent = ballMode === 'wire' ? 'WIRE' : 'SOLID';
    }

    // Initial gauge draw (empty)
    drawGauge(0, 200);

    await fetchSessions();
    renderSessionTable();

    // Auto-load the latest session if available
    if (allSessions.length > 0) {
        await loadSession(allSessions[0].id);
    } else {
        updateStats();
        updateDistribution();
        renderTimeline();
    }

    // Update settings on load
    updateSettings();
}

init();
</script>
</body>
</html>
